package com.example.jptang.test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LeedCode {

    /**
     * 两数之和
     给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
     你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
     示例:
     给定 nums = [2, 7, 11, 15], target = 9
     因为 nums[0] + nums[1] = 2 + 7 = 9
     所以返回 [0, 1]
     * @param nums
     * @param target
     * @return
     */
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(map.containsKey(target - nums[i])){
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return new int[]{0,0};
    }

    /**
     *寻找两个有序数组的中位数
     给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
     请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
     你可以假设 nums1 和 nums2 不会同时为空。
     示例 1:
     nums1 = [1, 3]
     nums2 = [2]
     则中位数是 2.0
     示例 2:
     nums1 = [1, 2]
     nums2 = [3, 4]
     则中位数是 (2 + 3)/2 = 2.5
     * @param nums1
     * @param nums2
     * @return
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int size1 = nums1.length;
        int size2 = nums2.length;
        int[] N;
        int[] M;
        if(size1>=size2){
            N = nums1;
            M = nums2;
        } else {
            N = nums2;
            M = nums1;
        }
        int iMin = 0, iMax = N.length;
        int i, j;
        while (iMin<=iMax){
            i = (iMin+iMax)/2;
            j = (N.length+M.length+1)/2 - i;
            if(i<iMax && M[j-1] > N[i]){
                //i增加
                iMin = i+1;
            } else if(i>iMin && N[i-1] > M[j]){
                //i减小
                iMax = i-1;
            } else{
                //符合条件
                int leftMax;
                int rightMin;
                if(i==0){
                    leftMax = M[M.length-1];
                    rightMin = N[0];
                } else if(j==0){
                    leftMax = N[N.length-1];
                    rightMin = M[0];
                } else{
                    leftMax = Math.max(N[i-1], M[j-1]);
                    rightMin = Math.min(N[i],M[j]);
                }
                if((N.length+M.length)%2==0){
                    return  (leftMax+rightMin)/2.0;
                }
                return leftMax;
            }
        }
        return 0.0;
    }
}
